{
  "fixes": [
    {
      "type": "measure",
      "table": "Orders+ (Sample - Superstore)",
      "name": "Order Level Sales (LOD)",
      "dax_expression": "CALCULATE(\n    SUM('Orders+ (Sample - Superstore)'[Sales]),\n    ALLEXCEPT(\n        'Orders+ (Sample - Superstore)',\n        'Orders+ (Sample - Superstore)'[Order ID]\n    )\n)",
      "solution_explanation": "Translates the FIXED LOD expression to a CALCULATE that aggregates SUM(Sales) while keeping only the Order ID partition using ALLEXCEPT. This produces the sum of sales fixed at the Order ID level.",
      "type_changed_reason": "This calculation uses a FIXED LOD expression which aggregates across rows, so it must be implemented as a measure in DAX."
    },
    {
      "type": "measure",
      "table": "Orders+ (Sample - Superstore)",
      "name": "Running Sales",
      "dax_expression": "VAR CurrentSales = SUM('Orders+ (Sample - Superstore)'[Sales])\nRETURN\nCALCULATE(\n    SUM('Orders+ (Sample - Superstore)'[Sales]),\n    FILTER(\n        ALLSELECTED('Orders+ (Sample - Superstore)'),\n        SUM('Orders+ (Sample - Superstore)'[Sales]) <= CurrentSales\n    )\n)",
      "solution_explanation": "Implements a running sum equivalent by computing the current row's SUM(Sales) and then summing Sales for all rows in ALLSELECTED whose aggregated Sales are less than or equal to the current row's aggregated Sales. This maps the table calculation RUNNING_SUM(SUM([Sales])) to a CALCULATE + FILTER pattern in DAX.",
      "type_changed_reason": "This is a table calculation (RUNNING_SUM over an aggregation) and therefore must be a measure."
    },
    {
      "type": "measure",
      "table": "Orders+ (Sample - Superstore)",
      "name": "% of Total Sales",
      "dax_expression": "DIVIDE(\n    SUM('Orders+ (Sample - Superstore)'[Sales]),\n    CALCULATE(\n        SUM('Orders+ (Sample - Superstore)'[Sales]),\n        ALLSELECTED('Orders+ (Sample - Superstore)')\n    ),\n    0\n)",
      "solution_explanation": "Replaces WINDOW_SUM(SUM([Sales])) with CALCULATE(..., ALLSELECTED(...)) to get the total within the current selection/window. Uses DIVIDE to handle division safely. This mirrors SUM([Sales]) / WINDOW_SUM(SUM([Sales])) in Tableau.",
      "type_changed_reason": "The formula uses aggregation and a table/window-level context (WINDOW_SUM), so it must be a measure."
    },
    {
      "type": "measure",
      "table": "Orders+ (Sample - Superstore)",
      "name": "Calculation2",
      "dax_expression": "CALCULATE(\n    MINX(\n        'Orders+ (Sample - Superstore)',\n        YEAR('Orders+ (Sample - Superstore)'[Order Date])\n    ),\n    ALLEXCEPT(\n        'Orders+ (Sample - Superstore)',\n        'Orders+ (Sample - Superstore)'[Customer ID]\n    )\n)",
      "solution_explanation": "Converts the FIXED LOD that computes the minimum YEAR(Order Date) per Customer ID into a CALCULATE with MINX over the table and ALLEXCEPT to fix the partition at Customer ID. This yields the minimum order year per customer.",
      "type_changed_reason": "This calculation uses a FIXED LOD expression with aggregation, so it should be implemented as a measure."
    },
    {
      "type": "measure",
      "table": "Orders+ (Sample - Superstore)",
      "name": "Calculation3",
      "dax_expression": "VAR CurrentSales = SUM('Orders+ (Sample - Superstore)'[Sales])\nVAR WindowTable =\n    FILTER(\n        ALLSELECTED('Orders+ (Sample - Superstore)'),\n        SUM('Orders+ (Sample - Superstore)'[Sales]) <= CurrentSales\n    )\nVAR WindowSum = CALCULATE(SUM('Orders+ (Sample - Superstore)'[Sales]), WindowTable)\nVAR WindowCount = COUNTROWS(WindowTable)\nRETURN DIVIDE(WindowSum, WindowCount, 0)",
      "solution_explanation": "Provides a window-average approximation by building a window table via ALLSELECTED and filtering rows by aggregated Sales relative to the current row, then dividing the window sum by the window row count. This maps the Tableau WINDOW_AVG(SUM([Sales]), -2, 0) intent to a DAX pattern using CALCULATE and FILTER to emulate window context.",
      "type_changed_reason": "This is a table calculation (WINDOW_AVG over an aggregation) and therefore must be a measure."
    },
    {
      "type": "measure",
      "table": "Orders+ (Sample - Superstore)",
      "name": "Calculation4",
      "dax_expression": "DIVIDE(\n    CALCULATE(\n        SUM('Orders+ (Sample - Superstore)'[Sales]),\n        ALLEXCEPT('Orders+ (Sample - Superstore)', 'Orders+ (Sample - Superstore)'[Customer ID], 'Orders+ (Sample - Superstore)'[Category])\n    ),\n    CALCULATE(\n        SUM('Orders+ (Sample - Superstore)'[Sales]),\n        ALLEXCEPT('Orders+ (Sample - Superstore)', 'Orders+ (Sample - Superstore)'[Customer ID])\n    ),\n    0\n)",
      "solution_explanation": "Implements the ratio of two FIXED LOD expressions by translating each FIXED into a CALCULATE with ALLEXCEPT to preserve the specified partition(s). The numerator fixes by Customer ID and Category; the denominator fixes by Customer ID. Uses DIVIDE to handle division by zero.",
      "type_changed_reason": "This formula is composed of FIXED LOD aggregations (sums partitioned by dimensions), so it must be created as a measure."
    }
  ]
}